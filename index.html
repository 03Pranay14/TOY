<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Rigged Picker Wheel</title>
    <style>
        /* --- RESET & BASICS --- */
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            color: #333;
        }

        /* --- LAYOUT --- */
        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Left Side: The Wheel */
        .wheel-section {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            position: relative;
            border-right: 1px solid #e5e7eb;
        }

        /* Right Side: Inputs Panel */
        .input-section {
            flex: 1;
            min-width: 300px;
            background-color: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        /* --- INPUTS PANEL STYLES --- */
        .panel-header {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 700;
            color: #111827;
        }

        .entry-count {
            background: #e5e7eb;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .input-list {
            flex-grow: 1;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            padding: 10px;
        }

        .input-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.2s;
        }

        .input-item:last-child { border-bottom: none; }
        
        .input-item.removed {
            opacity: 0.5;
            text-decoration: line-through;
            background-color: #fef2f2;
        }

        .input-checkbox {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            accent-color: #4F46E5;
            cursor: not-allowed;
        }

        .input-text {
            flex-grow: 1;
            font-size: 14px;
            color: #374151;
        }

        /* --- WHEEL STYLES --- */
        .wheel-container {
            position: relative;
            width: 80vh; /* Responsive based on height */
            height: 80vh;
            max-width: 600px;
            max-height: 600px;
            filter: drop-shadow(0 10px 25px rgba(0,0,0,0.15));
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 50%;
        }

        /* The Pointer (Triangle on the right) */
        .pointer {
            position: absolute;
            top: 50%;
            right: -25px; /* Stick out to the right */
            transform: translateY(-50%) rotate(-90deg);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 40px solid #333;
            z-index: 20;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        /* Center Spin Button */
        .spin-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: #1F2937; /* Dark button like screenshot */
            border-radius: 50%;
            border: 4px solid #ffffff;
            box-shadow: 0 0 0 2px #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 30;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }

        .spin-btn:hover { transform: translate(-50%, -50%) scale(1.05); background: #111827; }
        .spin-btn:active { transform: translate(-50%, -50%) scale(0.95); }
        
        .spin-text {
            color: white;
            font-weight: 800;
            font-size: 16px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* --- MODAL --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: white; padding: 40px; border-radius: 12px;
            text-align: center; width: 400px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
            transform: scale(0.9); transition: transform 0.3s;
        }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .result-value { font-size: 48px; font-weight: 800; color: #4F46E5; margin: 20px 0; }
        .close-btn {
            background: #4F46E5; color: white; border: none;
            padding: 10px 24px; border-radius: 6px;
            font-weight: 600; cursor: pointer; font-size: 16px;
        }
        .close-btn:hover { background: #4338ca; }

        /* Ads placeholder to look like screenshot footer */
        .footer-ad {
            height: 80px;
            background: #fffbeb;
            border-top: 1px solid #fcd34d;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #92400e;
            z-index: 50;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="wheel-section">
            <div class="wheel-container">
                <div class="pointer" style="right: -25px; top: 50%; transform: translateY(-50%) rotate(-90deg);"></div>
                <canvas id="wheelCanvas" width="800" height="800"></canvas>
                <div class="spin-btn" id="spinBtn">
                    <span class="spin-text">SPIN</span>
                </div>
            </div>
        </div>

        <div class="input-section">
            <div class="panel-header">
                <span class="panel-title">INPUTS</span>
                <span class="entry-count" id="entryCount">10</span>
            </div>
            
            <div class="input-list" id="inputList">
                </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal">
        <div class="modal-content">
            <h2 style="margin:0; color:#6B7280; font-size:18px;">We have a winner!</h2>
            <div class="result-value" id="resultValue">?</div>
            <button class="close-btn" id="closeModal">Done</button>
        </div>
    </div>

    <div class="footer-ad">
        <span style="font-weight:bold; margin-right: 10px;">Ad</span> Save 55% on Creative Cloud Pro.
    </div>

    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const inputListEl = document.getElementById('inputList');
        const entryCountEl = document.getElementById('entryCount');
        const modal = document.getElementById('modal');
        const resultValueEl = document.getElementById('resultValue');
        const closeModalBtn = document.getElementById('closeModal');

        // Current Active Items
        let items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        
        // Rigged Sequence (Fixed)
        // Logic: We will pick items from this list in order.
        // If an item is already removed, we skip it.
        const riggedSequence = [10, 5, 8, 7, 1, 3, 4, 2, 6, 9];
        let rigIndex = 0;

        // Visual Colors (Matching Earthy tones from screenshot + extras)
        const colors = [
            '#3b6e26', // Dark Green
            '#aeb041', // Olive/Gold
            '#f7b926', // Mustard Yellow
            '#e76f51', '#2a9d8f', '#264653', '#e9c46a', '#f4a261', '#e74c3c', '#8e44ad'
        ];

        // State
        let currentRotation = 0;
        let isSpinning = false;

        // --- RENDER INPUT LIST ---
        function renderInputList() {
            inputListEl.innerHTML = '';
            // We iterate through the original sequence to keep order, but check if they exist in 'items'
            const fullList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // Or we can just use current items
            
            // To show removed items as "crossed out", we need to know what was removed.
            // Let's use a master list.
            const masterList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            
            masterList.forEach(val => {
                const exists = items.includes(val);
                const div = document.createElement('div');
                div.className = `input-item ${exists ? '' : 'removed'}`;
                
                div.innerHTML = `
                    <input type="checkbox" class="input-checkbox" ${exists ? 'checked' : ''} disabled>
                    <span class="input-text">Option ${val}</span>
                `;
                inputListEl.appendChild(div);
            });

            entryCountEl.innerText = items.length;
        }

        // --- DRAW WHEEL ---
        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 10;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (items.length === 0) {
                // Empty Wheel State
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = "#eee";
                ctx.fill();
                return;
            }

            const arcSize = (Math.PI * 2) / items.length;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation * Math.PI / 180);

            items.forEach((item, i) => {
                const angle = i * arcSize;
                
                // Segment
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius, angle, angle + arcSize);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.2)";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text
                ctx.save();
                ctx.rotate(angle + arcSize / 2);
                ctx.textAlign = "right";
                ctx.fillStyle = "#fff";
                ctx.font = "bold 60px sans-serif";
                ctx.fillText(item, radius - 50, 20);
                ctx.restore();
            });

            ctx.restore();
        }

        // --- ANIMATION LOGIC ---
        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

        function spin() {
            if (isSpinning || items.length === 0) return;
            isSpinning = true;

            // 1. DETERMINE TARGET FROM RIGGED LIST
            let target = null;
            
            // Loop through rigged sequence to find the next available number
            // (In case the user manually modified things, or we just moved to next)
            while (target === null && rigIndex < riggedSequence.length) {
                const candidate = riggedSequence[rigIndex];
                if (items.includes(candidate)) {
                    target = candidate;
                    // Note: We do NOT increment rigIndex here. We increment it AFTER the spin completes.
                    // This ensures we don't skip numbers if the animation is cancelled.
                } else {
                    rigIndex++; // Skip this rigged number if it's not in the wheel anymore
                }
            }

            // Fallback: If rigged sequence is exhausted or invalid, pick random
            if (target === null) {
                const randomIdx = Math.floor(Math.random() * items.length);
                target = items[randomIdx];
            }

            // 2. CALCULATE ROTATION
            // Pointer is at 0 degrees (Right side) in Canvas terms (actually, let's fix the pointer logic).
            // In Canvas, 0 is 3 o'clock.
            // If we draw segments starting from 0, the first segment is 0 to (360/N).
            // To land Segment X on the Pointer (0 deg), we need to rotate the wheel such that Segment X is at 0.
            // Actually, visually, the pointer is at the Right (0 degrees).
            // So we need the center of the target segment to end up at 0 degrees (or 360).

            const targetIndex = items.indexOf(target);
            const segmentAngle = 360 / items.length;
            
            // The center of the target segment is currently at:
            // (targetIndex * segmentAngle) + (segmentAngle / 2)
            const currentPos = (targetIndex * segmentAngle) + (segmentAngle / 2);
            
            // We want to rotate the wheel backwards so this point hits 0.
            // Rotation = 360 - currentPos.
            // Add jitter
            const jitter = Math.floor(Math.random() * (segmentAngle * 0.8)) - (segmentAngle * 0.4);
            const landingRotation = 360 - currentPos + jitter;

            // Add spins (5 to 10 full spins)
            const extraSpins = (5 + Math.floor(Math.random() * 5)) * 360;
            const totalRotation = currentRotation + extraSpins + (landingRotation - (currentRotation % 360));
            
            // Ensure positive forward movement
            let finalTargetRot = totalRotation;
            if (finalTargetRot <= currentRotation) finalTargetRot += 360;

            // 3. ANIMATE
            const duration = 5000; // 5 seconds
            const startTime = performance.now();
            const startRot = currentRotation;

            function animate(now) {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = easeOutCubic(progress);

                currentRotation = startRot + (finalTargetRot - startRot) * ease;
                drawWheel();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    endGame(target);
                }
            }
            requestAnimationFrame(animate);
        }

        function endGame(target) {
            isSpinning = false;
            
            // Show Modal
            resultValueEl.innerText = target;
            modal.classList.add('active');

            // --- REMOVE LOGIC ---
            // 1. Remove from items array
            items = items.filter(i => i !== target);
            
            // 2. Advance Rigged Index (So next spin gets next number)
            rigIndex++;

            // 3. Update Inputs Panel UI
            renderInputList();
            
            // 4. Redraw wheel happens when modal closes to avoid jarring shift
        }

        // Close Modal & Redraw Wheel with removed item
        closeModalBtn.addEventListener('click', () => {
            modal.classList.remove('active');
            // The item was already removed from data, now we just see the updated wheel
            // We reset rotation visually to 0 to keep math simple for next spin? 
            // Or keep it. If we keep it, the segments shift.
            // Easier to keep current rotation but the segments will change size.
            // Let's just redraw.
            drawWheel();
        });

        spinBtn.addEventListener('click', spin);

        // Init
        renderInputList();
        drawWheel();
        
    </script>
</body>
</html>
